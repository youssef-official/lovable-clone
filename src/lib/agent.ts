import {
  openai,
  createAgent,
  createTool,
  createNetwork,
  type Tool,
  type AgentResult,
  type TextMessage,
} from "@inngest/agent-kit";
import { Sandbox } from "@e2b/code-interpreter";
import z from "zod";
import { PROMPT } from "@/prompt";
import { prisma } from "@/lib/db";
import { getBoilerplateFiles, initializeSandbox } from "./sandbox";
import { generateCodeFast } from "./fast-agent";

interface AgentState {
  summary: string;
  files: { [path: string]: string };
}

async function getSandbox(sandboxId: string) {
  const sandbox = await Sandbox.connect(sandboxId);
  return sandbox;
}

export async function generateProject(input: {
  value: string;
  projectId: string;
}) {
  console.log("Starting fast generation for project:", input.projectId);

  // Load conversation history to maintain context
  const previousMessages = await prisma.message.findMany({
    where: {
      projectId: input.projectId,
      type: {
        in: ["RESULT", "ERROR"], // Only load final results or errors
      },
      role: {
        in: ["USER", "ASSISTANT"],
      }
    },
    orderBy: {
      createdAt: "desc",
    },
    take: 10, // Limit context window
  });

  const history = previousMessages.reverse().map((msg) => ({
    role: msg.role.toLowerCase() as "user" | "assistant",
    content: msg.content,
  }));

  // Fetch the latest fragment to ensure we have the current file state
  const latestFragment = await prisma.fragment.findFirst({
    where: { message: { projectId: input.projectId } },
    orderBy: { createdAt: "desc" },
  });

  const existingFiles = (latestFragment?.files as Record<string, string>) || getBoilerplateFiles();
  const isEdit = !!latestFragment; // If there's a fragment, it's an edit

  try {
      // 1. Generate code using MiniMax (Fast Path)
      const { files: generatedFiles, summary } = await generateCodeFast({
          prompt: input.value,
          files: existingFiles,
          isEdit,
          conversationHistory: history
      });

      if (Object.keys(generatedFiles).length === 0) {
          throw new Error("No files generated by AI.");
      }

      // Merge new files with existing files
      const finalFiles = { ...existingFiles, ...generatedFiles };

      // 2. Start Sandbox (Background)
      const sandboxId = await (async () => {
        let sandbox;
        const templateId = process.env.E2B_TEMPLATE_ID || "vibe-nextjs-test-4";

        try {
          sandbox = await Sandbox.create(templateId, {
            timeoutMs: 30 * 60 * 1000, // 30 minutes
          });
        } catch (e) {
          console.warn(
            `Failed to load custom template "${templateId}". Falling back to base sandbox. Note: This may lack pre-installed dependencies. Error: ${e}`
          );
          sandbox = await Sandbox.create("base", {
            timeoutMs: 30 * 60 * 1000, // 30 minutes
          });
        }

        // Initialize sandbox (restore files if existing, or boilerplate if new)
        // We initialize with the FINAL files so the user sees the result immediately
        await initializeSandbox(sandbox, finalFiles);

        // Ensure the server is running on port 3000
        console.log("Ensuring server is running...");
        await sandbox.commands.run("if ! curl -s http://localhost:3000 > /dev/null; then npm run dev > /home/user/npm_output.log 2>&1 & fi");

        return sandbox.sandboxId;
      })();

      const sandboxUrl = await (async () => {
        const sandbox = await getSandbox(sandboxId);
        const host = sandbox.getHost(3000);
        return `https://${host}`;
      })();

      // 3. Save to Database
      return await prisma.message.create({
        data: {
          projectId: input.projectId,
          content: summary,
          role: "ASSISTANT",
          type: "RESULT",
          fragment: {
            create: {
              sandboxUrl: sandboxUrl,
              title: "Fragment",
              files: finalFiles,
            },
          },
        },
      });

  } catch (error: any) {
      console.error("Fast generation failed:", error);
      // Capture detailed error message for the user
      const errorMessage = error.message || "Something went wrong during generation. Please try again.";

      return await prisma.message.create({
        data: {
          projectId: input.projectId,
          content: `Error: ${errorMessage}`,
          role: "ASSISTANT",
          type: "ERROR",
        },
      });
  }
}
